### P7_CPU设计文档及思考题

#### MIPS微系统设计

##### 总述

P7的任务是设计一个MIPS微系统，不再仅仅局限于设计一个CPU，微系统需要考虑与外界的沟通，同时还需要CPU有能够自我纠错的能力。综上：我的设计是分为四个模块：CPU、Bridge、TC0、TC1。Bridge是CPU与外设沟通的渠道，TC0和TC1是计时器。

##### CPU

###### CP0

| 端口名称  | 方向 | 位宽 | 描述             |
| --------- | ---- | ---- | ---------------- |
| clk       | I    | 1    | 时钟信号         |
| reset     | I    | 1    | 重置信号         |
| we        | I    | 1    | 写使能信号       |
| CPUreg    | I    | 5    | 寄存器地址       |
| CP0in     | I    | 32   | CP0 写入数据     |
| CP0out    | O    | 32   | CP0 读出数据     |
| vpc       | I    | 32   | 受害 PC          |
| BDin      | I    | 1    | 是否是延迟槽指令 |
| ExcCodeIn | I    | 5    | 记录异常类型     |
| HWInt     | I    | 6    | 输入中断信号     |
| eret      | I    | 1    | 用来复位 EXL     |
| EPCout    | O    | 32   | EPC 的值         |
| req       | O    | 1    | 进入处理程序请求 |

###### Memory

CP0模块位于M级。

| 端口名称       | 方向 | 位宽 | 描述                                                         |
| -------------- | ---- | ---- | ------------------------------------------------------------ |
| d_bd           | I    | 1    | D级延迟槽指令                                                |
| e_bd           | I    | 1    | E级延迟槽指令                                                |
| m_bd           | I    | 1    | M级延迟槽指令                                                |
| d_exc          | I    | 5    | D级异常类型                                                  |
| e_exc          | I    | 5    | E级异常类型                                                  |
| m_exc          | I    | 5    | M级异常类型                                                  |
| HWInt          | I    | 6    | 输入中断信号                                                 |
| m_int_addr     | O    | 32   | 中断发生器待写入地址。当该信号命中中断发生器响应地址，且字节使能信号有效时，视为响应外部中断。 |
| m_int_byteen   | O    | 4    | 中断发生器字节使能信号，当该信号任意一位置位时视为有效。     |
| macroscopic_pc | O    | 32   | 宏观PC                                                       |
| eret           | O    | 1    | 异常返回指令信号                                             |
| req            | O    | 1    | 异常信号                                                     |
| EPC            | O    | 32   | EPC的值                                                      |
| br_in          | I    | 32   | Bridge读取的数据                                             |
| br_we          | O    | 1    | Bridge写入信号                                               |
| br_addr        | O    | 32   | Bridge写入的地址                                             |
| br_wd          | O    | 32   | Bridge写入的值                                               |

##### Bridge

| 端口名称 | 方向 | 位宽 | 描述              |
| -------- | ---- | ---- | ----------------- |
| br_in    | O    | 32   | 从地址读取的值    |
| br_we    | I    | 1    | Bridge写入信号    |
| br_addr  | I    | 32   | Bridge写入的地址  |
| br_wd    | I    | 32   | Bridge写入的值    |
| tc0      | I    | 32   | 从TC0中读取到的值 |
| tc1      | I    | 32   | 从TC1中读取到的值 |
| tc0_we   | O    | 1    | TC0写入信号       |
| tc1_we   | O    | 1    | TC1写入信号       |
| tc_in    | O    | 32   | 写入TC的值        |
| tc_addr  | O    | 32   | 写入TC的地址      |

##### TC

由两个TC组成，TC已由课程组设计完成，我们只需要在mips上连接信号即可。

#### 思考题

> 1、请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？

鼠标和键盘的输入信号最终被转换为数字形式，并通过输入/输出控制芯片传递到计算机的中央处理器，使系统能够根据用户的操作进行相应的处理。

> 2、请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）

中断异常处理需要指定固定的地址，主要是出于系统的稳定性和安全性考虑。如果允许用户自定义中断处理程序的入口地址，可能会导致系统不稳定、系统安全性遭到破坏以及系统状态的不一致。

> 3、为何与外设通信需要 Bridge？

Bridge计算机系统和外设之间起到了一个桥梁的作用，系统对外界数据的读取都可以通过Bridge来实现。通过Bridge可以确保不同类型的设备能够有效地协同工作，从而实现系统的灵活性。

> 4、请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。

相同点：都是用于产生中断信号，都涉及计数器的倒计数和初值寄存器的加载。

不同点：1、模式0的中断信号持续有效，而模式1每次计数循环只产生一次中断信号。2、模式0在计数器倒计数为0后停止计数，而模式1在倒计数为0后继续计数。3、模式0用于定时中断，模式1用于周期性脉冲。

![微信图片_20231216193757](D:\Desktop\照片\Pictures\Saved Pictures\微信图片_20231216193757.jpg)

> 5、倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？

会发生的问题是CPU此时不知道应该要进行的操作是什么，从而导致CPU要等待这条空泡指令执行完毕后才能响应中断，导致中断响应的延迟。应保留PC、指令信息。

> 6、为什么 `jalr` 指令为什么不能写成 `jalr $31, $31`？

jalr指令用于进行无条件跳转并将下一条指令的地址存储到目标寄存器中。如果将 `jalr` 指令写成 `jalr $31, $31`，意味着将链接寄存器 `$31` 的内容作为目标地址进行跳转，并且将当前指令的地址存储到 `$31`。这样会导致如果想要跳转回来，会陷入循环之中。