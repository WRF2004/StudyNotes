## P6_CPU设计文档及思考题

### CPU设计

P6需要我们新增指令。相较于P5，P6较大的改变在于IM和DM模块外置，同时在E级需要添加一个乘除模块以实现mult、multu、div、divu、mfhi、mflo、mthi、mtlo指令的添加。较为麻烦的一点在于，乘除指令运行时需要借助start和busy两个信号模拟延迟。乘法需要延迟5个周期，除法需要延迟10个周期。而对于sb、sh、lb、lh指令，教程提供了支持字节访存的教程，主要改动在于Controller和M级，M级新增了一个EXT模块以实现lb、lh指令的功能，Controller新增了若干信号。现将改动的模块进行介绍。

#### Execute

##### ALU

| 端口名称 | 方向 | 位宽 | 描述                                 |
| -------- | ---- | ---- | ------------------------------------ |
| w1       | I    | 32   | 第一个寄存器输入的数据               |
| w2       | I    | 32   | 第二个寄存器输入的数据               |
| cin      | I    | 1    | 减法信号(sub)                        |
| aluop    | I    | 1    | 或运算信号(ori or)                   |
| yu       | I    | 1    | 与运算信号(and andi)                 |
| cmp      | I    | 2    | 比较运算(slt: 2'b01 sltu: 2'b10)     |
| lui      | I    | 1    | lui指令运算                          |
| add      | I    | 1    | 加法运算(add sw lw sb sh lb lh addi) |
| aluout   | O    | 32   | 计算结果                             |

##### MD(乘除模块)

| 端口名称 | 方向 | 位宽 | 描述                       |
| -------- | ---- | ---- | -------------------------- |
| clk      | I    | 1    | 时钟信号                   |
| reset    | I    | 1    | 复位信号                   |
| w1       | I    | 32   | 第一个运算数据             |
| w2       | I    | 32   | 第二个运算数据             |
| HIw      | I    | 1    | mthi信号，将w1传给hi寄存器 |
| LOw      | I    | 1    | mtlo信号，将w1传给lo寄存器 |
| way      | I    | 3    | 运算类型                   |
| start    | I    | 1    | 运算开始信号               |
| busy     | O    | 1    | 延迟信号                   |
| hi       | O    | 32   | hi寄存器                   |
| lo       | O    | 32   | lo寄存器                   |

为满足题目要求，需添加三个寄存器：lo_temp, hi_temp, sign

lo_temp和hi_temp两个寄存器用于存储计算结果，在执行时间结束后存储在lo和hi寄存器中。sign寄存器用于实现延迟时间，乘法则赋值为5，除法则赋值为10。当sign不为0时，busy为1。

#### Controller

Controller模块新添加几个输出信号，用于添加指令的功能的实现。

| 端口名称      | 方向 | 位宽 | 描述                      |
| ------------- | ---- | ---- | ------------------------- |
| bne           | O    | 1    | bne指令                   |
| Op            | O    | 3    | 用于load型指令            |
| yu            | O    | 1    | 用于ALU中与运算           |
| cmp           | O    | 2    | 用于slt和sltu指令         |
| m_data_byteen | O    | 4    | 用于写存指令              |
| way           | O    | 3    | 乘除法指令                |
| LOw           | O    | 1    | mtlo指令                  |
| HIw           | O    | 1    | mthi指令                  |
| start         | O    | 1    | 乘除法开始指令            |
| mh            | O    | 1    | mfhi指令                  |
| ml            | O    | 1    | mflo指令                  |
| md            | O    | 1    | 8个乘除指令相关，用于暂停 |

#### Stall

de_stall指令信号调整：

```
assign de_stall = ((d_rs && d_instr[25:21] == e_a3 && e_a3 != 0 && e_not) || (d_rs && d_instr[25:21] == m_a3 && m_a3 != 0 && m_not && !(d_rs && d_instr[25:21] == e_a3 && e_a3 != 0 && !e_not)) ||
							 (d_rt && d_instr[20:16] == e_a3 && e_a3 != 0 && e_not) || (d_rt && d_instr[20:16] == m_a3 && m_a3 != 0 && m_not && !(d_rt && d_instr[20:16] == e_a3 && e_a3 != 0 && !e_not)) || ((start== 1 || busy == 1) && md == 1)) && !em_stall;
```

#### EXT

load型指令得到的值处理

| 端口名称     | 方向 | 位宽 | 描述             |
| ------------ | ---- | ---- | ---------------- |
| A            | I    | 2    | aluout的后两位   |
| Op           | I    | 3    | load型指令的类型 |
| m_data_rdata | I    | 32   | 从DM中取得的值   |
| Dout         | O    | 32   | 处理后得到的值   |

```
assign Dout = (A == 2'b00 && Op == 3'b010) ? {{24{m_data_rdata[7]}}, m_data_rdata[7:0]} :
					  (A == 2'b01 && Op == 3'b010) ? {{24{m_data_rdata[15]}}, m_data_rdata[15:8]} :
					  (A == 2'b10 && Op == 3'b010) ? {{24{m_data_rdata[23]}}, m_data_rdata[23:16]} :
					  (A == 2'b11 && Op == 3'b010) ? {{24{m_data_rdata[31]}}, m_data_rdata[31:24]} :
					  (A[1] == 0 && Op == 3'b100) ? {{16{m_data_rdata[15]}}, m_data_rdata[15:0]} :
					  (A[1] == 1 && Op == 3'b100) ? {{16{m_data_rdata[31]}}, m_data_rdata[31:16]} : m_data_rdata;
```

### 思考题

> 1、为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？

因为乘除模块中执行的乘除指令的行为与ALU中指令不同，它执行需要暂停时间，同时计算结果需存储在专门的寄存器中。

独立的HI、LO寄存器方便实现mfhi、mflo、mtlo、mthi指令。

> 2、真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。

流水线CPU使用一种称为乘法器和除法器的专用电路来实现乘法和除法操作。流水线CPU中的乘法器通常采用Booth算法或其改进版本。流水线CPU中的除法器通常采用迭代除法或牛顿-拉夫逊法等算法。这些算法通过多个迭代步骤逼近商的值。流水线CPU通过将乘法和除法操作划分为多个阶段，并采用并行处理的方式，实现了对这些复杂算术操作的高效执行。

> 3、请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？

在MD模块中加入计数寄存器sign。当乘法指令执行时，sign赋值为5；当除法指令执行时，sign赋值为10。当sign不为零时，busy赋值为1，其他则赋值为0。

> 4、请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）

**清晰性：** 使用字节使能信号可以使写操作更加清晰和灵活。字节使能信号允许精确地指定要写入的数据的字节位置，而不是整个数据都被写入。这提高了指令的清晰性，使程序员能够更精细地控制写操作。

**统一性：** 字节使能信号使得写指令在处理不同大小的数据时更加统一。不同的数据大小可以通过设置字节使能信号来实现，而无需修改指令格式。

> 5、请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？

不是，而是以32位为单位进行的。在处理特定格式数据的情况下按字节读和按字节写的效率会高于按字读和按字写。

> 6、为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？

对于一些相似的计算类型，增加类型信号以区分。如slt和sltu指令添加cmp信号，mult, multu, div, divu指令增加way型号。

修改更方便，区分更清晰，有效降低了复杂性。

> 7、在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？

load指令和乘除指令冲突、load类型指令和ALU计算指令。

对于load指令和乘除指令冲突，在MD模块添加start和busy信号，Controller模块中添加e_rs、e_rt、m_not信号。

```
addi $14, $0, 100
addi $20, $0, 100
ori $16 $0 16887
lh $18 -15527($16)
multu $14 $18
mtlo $14
mflo $11
bne $18 $0 bneConflict7_end
ori $17 $0 16569
sb $16 -12493($17)
addi $16 $17 19745
bneConflict7_end: nop
sub $19 $18 $17
and $18 $11 $20
mfhi $16
```

对于load指令和ALU指令冲突，在Controller模块中添加e_rs、e_rt、m_not信号。

```
addi $14, $0, 100
addi $20, $0, 100
ori $16 $0 16887
lh $18 -15527($16)
add $10, $18, $14
```

> 8、如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证**覆盖**了所有需要测试的情况；如果你是**完全随机**生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了**特殊的策略**，比如构造连续数据冒险序列，请你描述一下你使用的策略如何**结合了随机性**达到强测的效果。

我是完全随机生成的测试样例，不足之处：所有情况不一定能够覆盖，指令太多、太杂，bug不一定能够快速找出来。