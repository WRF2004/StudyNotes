### CPU设计文档及思考题

#### 设计草稿

CPU总体分为IFU Splitter Controller GRF ALU DM六个大模块

##### IFU

PC模块由寄存器和MUX组成，寄存器存储pc值，MUX用于reset时将pc值置为0x00003000，NPC模块用于计算下一个pc值，ROM输出指令。

| 端口名称 | 方向 | 位宽 | 描述                                        |
| -------- | ---- | ---- | ------------------------------------------- |
| clk      | I    | 1    | 时钟信号                                    |
| reset    | I    | 1    | 异步复位信号                                |
| offest   | I    | 16   | 位置偏移量，用于计算下一个PC                |
| result   | I    | 1    | rt与rs相减结果为0则置1，用于beq指令判断条件 |
| beq      | I    | 1    | beq指令出现则置1                            |
| Instr    | O    | 32   | 指令输出                                    |
| pc       | O    | 16   | pc值输出                                    |



##### Splitter

将Instr指令拆分

| 端口名称 | 方向 | 位宽 | 描述    |
| -------- | ---- | ---- | ------- |
| Instr    | I    | 32   | 指令    |
| imm16    | O    | 16   | [15:0]  |
| funct    | O    | 6    | [5:0]   |
| shamt    | O    | 5    | [10:6]  |
| rd       | O    | 5    | [15:11] |
| rt       | O    | 5    | [20:16] |
| rs       | O    | 5    | [25:21] |
| opcode   | O    | 6    | [31:26] |



##### Controller

Controller分为两部分，“AND”部分识别指令，“OR”部分输出命令信号。

| 端口名称 | 方向 | 位宽 | 描述                         |
| -------- | ---- | ---- | ---------------------------- |
| opcode   | I    | 6    | 指令操作码                   |
| funct    | I    | 6    | 细化指令操作                 |
| aluop    | O    | 1    | 判断ALU计算类型              |
| EXTop    | O    | 1    | 判断立即数扩展类型           |
| cin      | O    | 1    | 判断加减法类型               |
| Bsel     | O    | 1    | 判断输出立即数还是寄存器的值 |
| we       | O    | 1    | 判断输出是否输入             |
| RegC     | O    | 1    | 判断输入到rt还是rd           |
| lui      | O    | 1    | 判断是否执行lui操作          |
| WD       | O    | 1    | 判断DM是否输出               |
| beq      | O    | 1    | 判断是否执行beq操作          |
| sw       | O    | 1    | 判断DM是否输入               |



##### GRF

寄存器堆

| 端口名称 | 方向 | 位宽 | 描述           |
| -------- | ---- | ---- | -------------- |
| clk      | I    | 1    | 时钟信号       |
| reset    | I    | 1    | 异步复位信号   |
| we       | I    | 1    | 判断是否输入   |
| rs       | I    | 5    | rs寄存器地址   |
| rt       | I    | 5    | rt寄存器地址   |
| rd       | I    | 5    | 输入寄存器地址 |
| out      | I    | 32   | 输入值         |
| o1       | O    | 32   | 输出           |
| o2       | O    | 32   | 输出           |



##### ALU

计算模块

| 端口名称 | 方向 | 位宽 | 描述                      |
| -------- | ---- | ---- | ------------------------- |
| i1       | I    | 32   | 输入                      |
| i2       | I    | 32   | 输入                      |
| cin      | I    | 1    | 判断加减法                |
| aluop    | I    | 1    | 判断计算类型              |
| lui      | I    | 1    | 判断是否执行lui操作       |
| result   | O    | 1    | 判断beq操作下相减计算结果 |
| ALUout   | O    | 32   | ALU计算结果输出           |



##### DM

数据存储模块

| 端口名称 | 方向 | 位宽 | 描述         |
| -------- | ---- | ---- | ------------ |
| addr     | I    | 14   | 地址         |
| DMinput  | I    | 32   | 输入         |
| sw       | I    | 1    | 判断是否输入 |
| WD       | I    | 1    | 判断是否输出 |
| clk      | I    | 1    | 时钟信号     |
| reset    | I    | 1    | 异步复位信号 |
| DMout    | O    | 32   | 输出         |



#### 测试方案

```MIPS
.text
lui $t0, 1
beq $t0, $t1, for
add $t2, $t0, $t1
sub $t3, $t2, $t4
lw $t5, 0($t1)
sw $t1, 0($t6)
nop
for:
nop
```

```机器码
v2.0 raw
3c080001
11090005
01095020
01495822
8d2d0000
adc90000
00000000
00000000
```



#### 思考题

> 1、上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。

状态存储：IFU中的PC模块、GRF、DM

状态转移：IFU中NPC模块、Controller、ALU



> 2、现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。

合理。

1. 因为指令在运行时不会被修改，所以IM使用只读存储器(ROM)是合适的。
2. 数据在程序执行时需要进行读取和写入操作，RAM根据地址可以进行读取和写入操作，所以是合理的。
3. 寄存器可以随时钟信号读取和写入数据，同时也可以实现异步复位，所以GRF中用32个寄存器来拿存储程序运行时产生的数据是合理的。

> 3、在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。

我设计了Splitter模块。

介绍：Splitter模块可将指令拆分成opcode rs rt rd imm16 shamt funct等部分，便于后续识别指令、寻址操作和运算操作的实现。

设计思路：输入32位指令，在Splitter模块中多次使用logisim中的splitter元件将32位指令拆分，并分别输出。

> 4、事实上，实现 `nop` 空指令，我们并不需要将它加入控制信号真值表，为什么？

nop指令不执行实际操作，pc + 4即可，所以其不需要加入控制信号真值表中。

> 5、阅读 Pre 的 [“MIPS 指令集及汇编语言”](http://cscore.buaa.edu.cn/tutorial/mips/mips-6/mips6-1/) 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。

指令覆盖情况好，每个指令都覆盖到了，单一指令的各种行为也基本覆盖到了

不足之处：1、加法运算时未考虑使用32位数边界附近的数来测试溢出时的结果，也没使用32位数范围内的一些随机数来测试。

2、lw和sw中的offest未考虑负数的情况,，lw指令未测试目标寄存器是$0的情况。

3、beq指令没有考虑跳转，且目标在此跳转指令之前和目标是此跳转指令和不跳转，且目标在此跳转指令之前和目标是此跳转指令的情况。



